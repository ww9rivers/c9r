#!/usr/bin/env python
#
#       $Id: __init__.py,v 1.7 2015/01/07 20:00:57 weiwang Exp $
#
## This program is licensed under the GPL v3.0, which is found at the URL below:
##	http://opensource.org/licenses/gpl-3.0.html
##
## Copyright (c) 2012, 9Rivers.NET, LLC.  All rights reserved.


'''
Package to define a CLI plugin structure.

Deferring this plugin mechanism because there seems to be a bug in Twisted on
SuSE Enterprise server 11.1 -- This may be revisited later.

from zope.interface import Interface, Attribute
'''
from cStringIO import StringIO
from c9r.pylog import logger


class CLI(object):
    """
    Command line plugin interface.
    """
    command = ''
    '''
    @type command: C{string}
    @ivar command: A command to execute on a device.
    '''
    regex = []

    def auto_regex(self, data, pattern):
        '''
        (This seems to be incomplete.)
        '''
        ts = self.data_stream(data)

    def data_stream(self, data):
        '''Convert given data (string type) to a readable object.

        2014-08-12: Why did I wrap (data) in unicode when converting to StringIO?
        '''
        return data if callable(getattr(data, 'next', None)) else StringIO(data)

    def parse(self, data):
        '''
        Parse data provided into a table (list) of dict's, each of those generated by a
        matching regular expression.
        '''
        result = []
        for line in self.data_stream(data):
            #logger.debug('line = {0}'.format(line[:-1]))
            for rex in self.re:
                mx = rex.match(line)
                if mx:
                    result.append(mx.groupdict())
                    break
        #logger.debug('results = {0}'.format(result))
        return result

    def parse_cols(self, data, thre=None):
        '''Parse data into a table based on table fixed head.

        /data/ is the data to be parsed.

        /thre/ is an optional table head regex. If omitted, the head will be calculated with the
        assumption that the columns are left aligned strictly to the headers.

        An example usage of this function is parsing the result of Cisco IOS'
        "show interface status" command. See cisco/cli/port.py.
        '''
        mh = None
        mlen = None
        thre = thre or self.headrex
        lines = self.data_stream(data)
        result = []
        for line in lines: # Skip anything that does not match the table head regex
            mh = thre.findall(line)
            if mh:
                mlen = [0] + [len(x) for x in mh]
                for i in range(0, len(mh)):
                    mlen[i+1] += mlen[i]
                mh = [x.strip().lower() for x in mh]
                for line in lines:
                    for ex in self.efilters:
                        if ex.match(line):
                            break
                    else:
                        result.append([line[mlen[i]:mlen[i+1]].strip() for i in range(0, len(mh))])
                break
        return mh, result

    def __init__(self, conf=None):
        '''
        Initialize this CLI object: compile the class regular expression. A
        sub-class may define a list of (keys) that can be inserted into the
        (regex) string before it is compiled, with each occurance of '%s' in
        (regex) with '?P<key>' where (key) is an element in the (keys) list.
        '''
        self.C = conf
        import re
        regexs = [rex[1] % tuple('?P<%s>'%k for k in rex[0]) if isinstance(rex, list) else rex\
                      for rex in (self.regex
                                  if isinstance(self.regex, list)
                                  else [self.regex] if isinstance(self.regex, basestring) else [])]
        self.re = [re.compile(rex) for rex in regexs]
        #[ logger.debug('Regex = {0}'.format(rex)) for rex in regexs ]
        #logger.debug('Total regex = {0}'.format(len(self.re)))
        # Default regex'es:
        self.headrex = re.compile('(\s*\w+\s*)')  # Table head marker
        self.efilters = [ re.compile(x) for x in  # exclusion filters
                          [
                              '^-+$'            # Entire line of ----
                              ]
                          ]
